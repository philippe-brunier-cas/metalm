---
title: "Data Preparation "
subtitle: "metalm"
author: "philippe.brunier@cogne.com"
version: 1.0 
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    css: ./custom.css
    df_print: paged
    gallery: no
    highlight: default
    html_document: null
    lightbox: yes
    number_sections: yes
    self_contained: yes
    thumbnails: no
editor_options:
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      message = FALSE,
                      error = FALSE,
                      fig.height = 7,
                      fig.width = 10,
                      collapse = TRUE,
                      cols.print=20)
rm(list = ls(all.names = TRUE))

require(dplyr)
require(kableExtra)
require(readr)
require(reticulate)
source('~/dev/metalm/R/function.R')
```

# Creazione del database

Viene creato un database che racchiude le informazioni riassunte per sk. 
E' composto come segue:

+ tempo limite (usura)
+ forza prima passata (usura)
+ forza di picco (usura)
+ chimiche di prodotto 
+ prove meccaniche (trazioni, durezze)

(la mappatura Ã¨ coerente con le tabelle precedenti) 


## loading database

carico i file, li mappo e li salvo come pkl

```{python join dati e mappe, include = TRUE}

import pandas as pd
import numpy as np

######## opt

headerpath = '/data/metalm/header/head_opt.csv'
filepath = '/data/metalm/database_opt.csv'
    
#carico l'header

header = pd.read_csv(headerpath,sep=';')
nomi_colonne = list(header.col_name)

# creo il dizionario per i data type 
r,c = header.shape

dict_types = {}
for i in range(0,r):
    dict_types[nomi_colonne[i]] = header.data_type[i]


#carico il csv
try:
    
    df_opt = pd.read_csv(filepath,sep='|',
                       names=nomi_colonne,
                        dtype = dict_types,
                        skiprows=[0],
                       )
except ValueError:
    print('warning!!! --> dizionario non preso')
    df_opt = pd.read_csv(filepath,sep='|',
                       names=nomi_colonne,
                        # dtype = dict_types,
                        skiprows=[0],
                       )    

# ciclo per togliere in \n dalla colonna materiali

new_mat = []
for mat in df_opt.materiale:
  new_mat.append(str(mat).replace('\n',''))

df_opt.materiale = new_mat

df_opt = df_opt.to_pickle('/data/metalm/pickle/opt.pkl')


######## wear

headerpath = '/data/metalm/header/head_wear.csv'
filepath = '/data/metalm/dati_wear.csv'
    
#carico l'header

header = pd.read_csv(headerpath,sep=';')
nomi_colonne = list(header.col_name)

# creo il dizionario per i data type 
r,c = header.shape

dict_types = {}
for i in range(0,r):
    dict_types[nomi_colonne[i]] = header.data_type[i]


#carico il csv
try:
    
    df_wear = pd.read_csv(filepath,sep='|',
                       names=nomi_colonne,
                        dtype = dict_types,
                        skiprows=[0]
                       )
except ValueError:
    print('warning!!! --> dizionario non preso')
    df_wear = pd.read_csv(filepath,sep='|',
                       names=nomi_colonne,
                        # dtype = dict_types,
                        skiprows=[0],
                       )    

df_wear = df_wear.to_pickle('/data/metalm/pickle/wear.pkl')

######## ossidi

headerpath = '/data/metalm/header/head_ox.csv'
filepath = '/data/metalm/tabella_ossidi.csv'
    
#carico l'header

header = pd.read_csv(headerpath,sep=';')
nomi_colonne = list(header.col_name)

# creo il dizionario per i data type 
r,c = header.shape

dict_types = {}
for i in range(0,r):
    dict_types[nomi_colonne[i]] = header.data_type[i]


#carico il csv
try:
    
    df_ox = pd.read_csv(filepath,sep='|',
                       names=nomi_colonne,
                        dtype = dict_types,
                        skiprows=[0],
                       )
except ValueError:
    print('warning!!! --> dizionario non preso')
    df_ox = pd.read_csv(filepath,sep='|',
                       names=nomi_colonne,
                        # dtype = dict_types,
                        skiprows=[0],
                       )    

df_ox = df_ox.to_pickle('/data/metalm/pickle/ossidi.pkl')


######## metallografiche

headerpath = '/data/metalm/header/head_met.csv'
filepath = '/data/metalm/analisi_metallografiche.csv'
    
#carico l'header

header = pd.read_csv(headerpath,sep=';')
nomi_colonne = list(header.col_name)

# creo il dizionario per i data type 
r,c = header.shape

dict_types = {}
for i in range(0,r):
    dict_types[nomi_colonne[i]] = header.data_type[i]


#carico il csv
try:
    
    df_ox = pd.read_csv(filepath,sep='|',
                       names=nomi_colonne,
                        dtype = dict_types,
                        skiprows=[0],na_values='na')
                
except ValueError:
    print('warning!!! --> dizionario non preso')
    df_ox = pd.read_csv(filepath,sep='|',
                       names=nomi_colonne,
                        # dtype = dict_types,
                        skiprows=[0],na_values='na')
                       
for i in range(3,23):
  df_ox[df_ox.columns[i]]=df_ox[df_ox.columns[i]].replace('below_limit',float(0))
  
  #df_met[df_ox.columns[i]]=pd.to_numeric(df_ox[df_ox.columns[i]])
    
df_ox = df_ox[df_ox.sk != 'na']
df_ox = df_ox.to_pickle('/data/metalm/pickle/met.pkl')


```

estraggo le informazioni d'interesse per le corelazioni

```{python aserty}

```

+ la tripla ottimale

```{r qwerty}

```


uniamo queste due informazioni al database precedente

```{r zerty}

```

contiamo le righe 

```{r serty}

```

salvo il database come .pkl
```{python xerty}
"""
save as pkl
print df.head()
"""
```

